user www-data;

# set your processor core(s)
#worker_processes auto;
#
# cat /proc/cpuinfo | grep processor | wc -l
#
#worker_processes 1;
#
#worker_processes 2;
#worker_cpu_affinity 0001 0010;
#
worker_processes 4;
worker_cpu_affinity 0001 0010 0100 1000;

worker_rlimit_nofile 8192;
pid /var/run/nginx.pid;

# [ debug | info | notice | warn | error | crit ] 
error_log /var/log/nginx/error.log;

#google_perftools_profiles /tmp/profile/;

events {
  # The worker_connections and worker_proceses from the main section 
  # allows you to calculate maxclients value:
  #
  # max_clients = worker_processes * worker_connections
  #
  # In a reverse proxy situation, max_clients becomes
  # max_clients = worker_processes * worker_connections/4
  #
  # Since a browser opens 2 connections by default to a server 
  # and nginx uses the fds (file descriptors) from the same pool 
  # to connect to the upstream backend
  # 
  worker_connections 1000;

  # If you have more than one event-model specified at the ./configure 
  # script, then you can tell nginx which one do you want to use. 
  # By default nginx looks for the most suitable method for your OS 
  # at ./configure time.
  #
  # You can see the available event-models and how you can activate 
  # it at the ./configure -> http://wiki.nginx.org/NginxOptimizations
  #
  # use [ kqueue | rtsig | epoll | /dev/poll | select | poll ] ;
  use epoll;

  # multi_accept tries to accept() as many connections as 
  # possible after nginx gets notification about a new connection.
  # default: off
  multi_accept on;

  # If a worker process does not have accept mutex it will 
  # try to aquire it at least after this delay.
  # default: 500ms
  accept_mutex_delay 50ms;
}

http {
  ## Hostname Options 
  server_name_in_redirect on;
  server_names_hash_bucket_size 64;
  server_names_hash_max_size 512;

  ## Size Limits
  client_max_body_size 10M;
  client_header_buffer_size 1k;
  client_body_buffer_size 32k;
  large_client_header_buffers 4 8k;

  ## Timeouts
  client_body_timeout 1m;
  client_header_timeout 1m;
  send_timeout 1m;
  # expires 24h;

  # The first parameter assigns the timeout for keep-alive connections 
  # with the client. The server will close connections after this time.
  #
  # The optional second parameter assigns the time value in the header 
  # Keep-Alive: timeout=time of the response. This header can convince 
  # some browsers to close the connection, so that the server does not
  # have to. Without this parameter, nginx does not send a Keep-Alive
  # header (though this is not what makes a connection "keep-alive").
  #
  # The parameters can differ from each other.
  #
  # Notes on how browsers handle the Keep-Alive header:
  #
  # MSIE and Opera ignore the "Keep-Alive: timeout=<N>" header.
  # MSIE keeps the connection alive for about 60-65 seconds, then sends a TCP RST.
  # Opera keeps the connection alive for a long time.
  # Mozilla keeps the connection alive for N plus about 1-10 seconds.
  # Konqueror keeps the connection alive for about N seconds.
  # default: keepalive_timeout 75
  keepalive_timeout 10 10;
  keepalive_requests 100;

  ## Reset lingering timed out connections. Deflect DDoS.
  reset_timedout_connection on;

  ##
  # Basic Settings
  ##
  charset utf-8;
  index index.php index.htm index.html redirect.php;
  ignore_invalid_headers on;
  #limit_zone normal $binary_remote_addr 5m;
  #limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;
  recursive_error_pages on;
  types_hash_max_size 2048;

  ## Hide the Nginx version number.
  server_tokens off;

  # to boost IO on HDD we can disable access logs
  # access_log off;

  # Tell Nginx not to send out partial frames; this increases throughput
  # since TCP frames are filled up before being sent out. (adds TCP_CORK)
  tcp_nopush      on;

  # Tell Nginx to enable the Nagle buffering algorithm for TCP packets, which
  # collates several smaller packets together into one larger packet, thus saving
  # bandwidth at the cost of a nearly imperceptible increase to latency. (removes TCP_NODELAY)
  tcp_nodelay     off;

  ## Proxy Options
  # set_real_ip_from 127.0.0.1;
  # real_ip_header X-Forwarded-For;

  ## Use sendfile() syscall to speed up I/O operations and speed up
  ## static file serving.
  sendfile on;

  ## Use a SSL/TLS cache for SSL session resume. This needs to be
  ## here (in this context, for session resumption to work. See this
  ## thread on the Nginx mailing list:
  ## http://nginx.org/pipermail/nginx/2010-November/023736.html.
  ssl_session_cache shared:SSL:10m;
  ssl_session_timeout 10m;
  ssl_ciphers  HIGH:!aNULL:!MD5;
  ssl_prefer_server_ciphers on;

  ## Enable clickjacking protection in modern browsers. Available in
  ## IE8 also. See
  ## https://developer.mozilla.org/en/The_X-FRAME-OPTIONS_response_header
  add_header X-Frame-Options SAMEORIGIN;

  # when serving user-supplied content, include a X-Content-Type-Options: nosniff header along with the Content-Type: header,
  # to disable content-type sniffing on some browsers.
  # https://www.owasp.org/index.php/List_of_useful_HTTP_headers
  # currently suppoorted in IE > 8 http://blogs.msdn.com/b/ie/archive/2008/09/02/ie8-security-part-vi-beta-2-update.aspx
  # http://msdn.microsoft.com/en-us/library/ie/gg622941(v=vs.85).aspx
  # 'soon' on Firefox https://bugzilla.mozilla.org/show_bug.cgi?id=471020
  add_header X-Content-Type-Options nosniff;
 
  # This header enables the Cross-site scripting (XSS) filter built into most recent web browsers.
  # It's usually enabled by default anyway, so the role of this header is to re-enable the filter for 
  # this particular website if it was disabled by the user.
  # https://www.owasp.org/index.php/List_of_useful_HTTP_headers
  add_header X-XSS-Protection "1; mode=block";
 
  # with Content Security Policy (CSP) enabled(and a browser that supports it(http://caniuse.com/#feat=contentsecuritypolicy),
  # you can tell the browser that it can only download content from the domains you explicitly allow
  # http://www.html5rocks.com/en/tutorials/security/content-security-policy/
  # https://www.owasp.org/index.php/Content_Security_Policy
  # I need to change our application code so we can increase security by disabling 'unsafe-inline' 'unsafe-eval'
  # directives for css and js(if you have inline css or js, you will need to keep it too).
  # more: http://www.html5rocks.com/en/tutorials/security/content-security-policy/#inline-code-considered-harmful
  #add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://ssl.google-analytics.com https://assets.zendesk.com https://connect.facebook.net; img-src 'self' https://ssl.google-analytics.com https://s-static.ak.facebook.com https://assets.zendesk.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://assets.zendesk.com; font-src 'self' https://themes.googleusercontent.com; frame-src https://assets.zendesk.com https://www.facebook.com https://s-static.ak.facebook.com https://tautt.zendesk.com; object-src 'none'";

  ## Define a zone for limiting the number of simultaneous
  ## connections nginx accepts. 1m means 32000 simultaneous
  ## sessions. We need to define for each server the limit_conn
  ## value refering to this or other zones.
  ## ** This syntax requires nginx version >=
  ## ** 1.1.8. Cf. http://nginx.org/en/CHANGES. If using an older
  ## ** version then use the limit_zone directive below
  ## ** instead. Comment out this
  ## ** one if not using nginx version >= 1.1.8.
  #limit_conn_zone $binary_remote_addr zone=arbeit:10m;

  #include /etc/nginx/mime.types;
  include mime.types;
  default_type application/octet-stream;

  # Update charset_types due to updated mime.types
  charset_types text/xml text/plain text/vnd.wap.wml application/x-javascript application/rss+xml text/css application/javascript application/json;


  ## Logfile Options
  access_log /var/log/nginx/access.log;
  log_format main '$remote_addr - $remote_user [$time_local] $status '
  '\"$request\" $body_bytes_sent \"$http_referer\" '
  '\"$http_user_agent\" \"http_x_forwarded_for\"';

  # Caches information about open FDs, freqently accessed files.
  #open_file_cache max=1000 inactive=150s; 
  #open_file_cache_valid    160s; 
  #open_file_cache_min_uses 2;
  #open_file_cache_errors   on;
  #fastcgi_cache_path /var/cache/nginx levels=1:2 keys_zone=microcache:10m max_size=1000m inactive=60m;

  ##
  # Gzip Settings
  ##
  gzip              on;
  gzip_disable      "msie6";
  # gzip_disable      "MSIE [1-6].(?!.*SV1)"; # old value
  gzip_vary         on;
  gzip_proxied      any;
  gzip_buffers      16 8k;

  # Compression level (1-9).
  # 5 is a perfect compromise between size and cpu usage, offering about
  # 75% reduction for most ascii files (almost identical to level 9).
  gzip_comp_level   5;

  # Enable compression both for HTTP/1.0 and HTTP/1.1
  gzip_http_version 1.0;

  # Don't compress anything that's already small and unlikely to shrink much
  # if at all (the default is 20 bytes, which is bad as that usually leads to
  # larger files after gzipping).
  gzip_min_length   1024;

  # Compress all output labeled with one of the following MIME-types.
  gzip_types
    application/atom+xml
    application/javascript
    application/json
    application/rss+xml
    application/vnd.ms-fontobject
    application/x-font-ttf
    application/x-web-app-manifest+json
    application/x-javascript
    application/xhtml+xml
    application/xml
    font/opentype
    image/svg+xml
    image/x-icon
    text/css
    text/plain
    text/x-component;
  # text/html is always compressed by HttpGzipModule

  # This should be turned on if you are going to have pre-compressed copies (.gz) of
  # static files available. If not it should be left off as it will cause extra I/O
  # for the check. It is best if you enable this in a location{} block for
  # a specific directory, or on an individual server{} level.
  # gzip_static on;

  #pagespeed on;
  #pagespeed FileCachePath              "/var/ngx_pagespeed_cache";
  #pagespeed FileCacheSizeKb            102400;
  #pagespeed FileCacheCleanIntervalMs   3600000;
  #pagespeed FileCacheInodeLimit        500000;
  #pagespeed FetchWithGzip on;
  #pagespeed EnableFilters combine_css,combine_javascript;

  #output_buffers   10 128k;
  #postpone_output  1500;

  ## FastCGI Optins
  ## http://wiki.nginx.org/HttpFastcgiModule#fastcgi_buffers
  ## This directive determines if current request to the FastCGI-server must be aborted in case the client aborts the request to the server.
  fastcgi_ignore_client_abort on;
  ## This directive sets the number and the size of the buffers into which the reply from the FastCGI process in the backend is read.
  fastcgi_buffers 256 16k; # 16k + 256 * 16k = 4112k total
  fastcgi_buffer_size 128k;
  fastcgi_busy_buffers_size 256k;
  ## disable buffering to disk if replies start to exceeed your fastcgi buffers
  fastcgi_max_temp_file_size 0;
  fastcgi_index  index.php;
  fastcgi_connect_timeout 120;
  ## allow 4 hrs - pass timeout responsibility to upstream
  fastcgi_read_timeout 14400;
  # fastcgi_send_timeout 120;
  ## This directive determines whether or not to transfer 4xx and 5xx errors back to the client or to allow Nginx to answer with directive error_page.
  fastcgi_intercept_errors on;
  ## When set to the value on, nginx will instruct a FastCGI server to keep connections open.
  fastcgi_keep_conn on;

# ------------------------------------------------------------------ #

  # Example: Loadbalance
# upstream webbackend  {
#   ip_hash;
#   server web1.domain.lan weight=10 max_fails=3 fail_timeout=30s;
#   server web2.domain.lan weight=1 backup;
# }

  # Example: Reverse-Proxy
# server {
#   access_log  /var/log/nginx/access.proxy.log main;
#   error_log   /var/log/nginx/error.proxy.log;
#   listen      80;
#   server_name _;

    ## PROXY - Web
#   location ~ \.php$ {
#     proxy_cache            cache;
#     proxy_pass  http://127.0.0.1:8080;
#   }
# }

  # Example: HTTP Server (add the config to a new folder e.g.: /etc/nginx/sites-available/)
# server {
#   listen       8000;
#   listen       somename:8080;
#   server_name  somename  alias  another.alias;

#   location / {
#     root   html;
#     index  index.html index.htm;
#   }
# }

  # Example: HTTPS Server (add the config to a new folder e.g.: /etc/nginx/sites-available/) 
# server {
#   listen       443;
#   server_name  localhost;

#   ssl                  on;
#   ssl_certificate      cert.pem;
#   ssl_certificate_key  cert.key;

#   ssl_session_timeout  5m;

#   ssl_protocols  SSLv2 SSLv3 TLSv1;
#   ssl_ciphers  ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;
#   ssl_prefer_server_ciphers   on;

#   location / {
#     root   html;
#     index  index.html index.htm;
#   }
# }

  ##
  # If HTTPS, then set a variable so it can be passed along.
  ##
  map $scheme $server_https {
    default off;
    https on;
  }


# mail {
  ## See sample authentication script at:
  ## http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript

#   auth_http localhost/auth.php;
#   pop3_capabilities "TOP" "USER";
#   imap_capabilities "IMAP4rev1" "UIDPLUS";

#      server {
#              listen     localhost:110;
#              protocol   pop3;
#              proxy      on;
#      }

#      server {
#              listen     localhost:143;
#              protocol   imap;
#              proxy      on;
#      }
# }

  ##
  # Virtual Host Configs
  include /etc/nginx/sites-enabled/*.conf;

  ## Include blacklist for bad bot and referer blocking.
  include /etc/nginx/blacklist.conf;
}
